<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/include/node_thread.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/include/node_thread.h" />
              <option name="originalContent" value="#ifndef NODE_THREAD_H&#10;#define NODE_THREAD_H&#10;&#10;#include &lt;libplatform/libplatform.h&gt;&#10;#include &lt;node.h&gt;&#10;#include &lt;uv.h&gt;&#10;#include &lt;v8.h&gt;&#10;&#10;#include &lt;QObject&gt;&#10;#include &lt;QThread&gt;&#10;#include &lt;QMutex&gt;&#10;#include &lt;QWaitCondition&gt;&#10;#include &lt;QQueue&gt;&#10;#include &lt;QJsonObject&gt;&#10;#include &lt;QUuid&gt;&#10;#include &lt;QMap&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;functional&gt;&#10;#include &lt;atomic&gt;&#10;&#10;struct NodeMessage {&#10;    QString messageId;&#10;    QString action;&#10;    QJsonObject params;&#10;    std::function&lt;void(const QJsonObject&amp;)&gt; callback;&#10;};&#10;&#10;class NodeThread : public QThread {&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit NodeThread(QObject *parent = nullptr);&#10;    ~NodeThread();&#10;    &#10;    bool initialize();&#10;    void shutdown();&#10;    &#10;    // Direct message sending (thread-safe via Qt's signal-slot mechanism)&#10;    void sendMessage(const QString &amp;action, const QJsonObject &amp;params, std::function&lt;void(const QJsonObject&amp;)&gt; callback);&#10;&#10;signals:&#10;    void messageProcessed(const QJsonObject &amp;result);&#10;&#10;protected:&#10;    void run() override;&#10;&#10;private:&#10;    bool initializeNodeEnvironment();&#10;    bool loadJSEntryPoint();&#10;    void processMessages();&#10;    void handleNodeMessage(const NodeMessage &amp;message);&#10;    static void nativeCallback(const v8::FunctionCallbackInfo&lt;v8::Value&gt; &amp;args);&#10;    static void loadFromQrc(const v8::FunctionCallbackInfo&lt;v8::Value&gt; &amp;args);&#10;&#10;    // Node.js environment&#10;    std::unique_ptr&lt;node::CommonEnvironmentSetup&gt; m_setup;&#10;    std::unique_ptr&lt;node::MultiIsolatePlatform&gt; m_platform;&#10;    std::unique_ptr&lt;node::InitializationResult&gt; m_initResult;&#10;    v8::Isolate *m_isolate;&#10;    node::Environment *m_env;&#10;    v8::Global&lt;v8::Function&gt; m_handleMessageFunction;&#10;    &#10;    // Thread synchronization&#10;    QMutex m_messageMutex;&#10;    QWaitCondition m_messageCondition;&#10;    QQueue&lt;NodeMessage&gt; m_messageQueue;&#10;    std::atomic&lt;bool&gt; m_running;&#10;    &#10;    // Callback storage for concurrent messages&#10;    QMap&lt;QString, std::function&lt;void(const QJsonObject&amp;)&gt;&gt; m_callbacks;&#10;    QMutex m_callbackMutex;&#10;    &#10;    static const char* JS_ENTRY_PATH;&#10;    static const char* JS_ENTRY_QRC_PATH;&#10;    static NodeThread* s_instance;&#10;};&#10;&#10;#endif // NODE_THREAD_H&#10;" />
              <option name="updatedContent" value="#ifndef NODE_THREAD_H&#10;#define NODE_THREAD_H&#10;&#10;#include &lt;libplatform/libplatform.h&gt;&#10;#include &lt;node.h&gt;&#10;#include &lt;uv.h&gt;&#10;#include &lt;v8.h&gt;&#10;&#10;#include &lt;QObject&gt;&#10;#include &lt;QThread&gt;&#10;#include &lt;QMutex&gt;&#10;#include &lt;QWaitCondition&gt;&#10;#include &lt;QQueue&gt;&#10;#include &lt;QJsonObject&gt;&#10;#include &lt;QUuid&gt;&#10;#include &lt;QMap&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;functional&gt;&#10;#include &lt;atomic&gt;&#10;&#10;struct NodeMessage {&#10;    QString messageId;&#10;    QString action;&#10;    QJsonObject params;&#10;    std::function&lt;void(const QJsonObject&amp;)&gt; callback;&#10;};&#10;&#10;class NodeThread : public QThread {&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit NodeThread(QObject *parent = nullptr);&#10;    ~NodeThread();&#10;    &#10;    bool initialize();&#10;    void shutdown();&#10;    &#10;    // Direct message sending (thread-safe via Qt's signal-slot mechanism)&#10;    void sendMessage(const QString &amp;action, const QJsonObject &amp;params, std::function&lt;void(const QJsonObject&amp;)&gt; callback);&#10;&#10;signals:&#10;    void messageProcessed(const QJsonObject &amp;result);&#10;    void initializationFailed(const QString &amp;error);&#10;&#10;protected:&#10;    void run() override;&#10;&#10;private:&#10;    bool initializeNodeEnvironment();&#10;    bool loadJSEntryPoint();&#10;    void processMessages();&#10;    void handleNodeMessage(const NodeMessage &amp;message);&#10;    static void nativeCallback(const v8::FunctionCallbackInfo&lt;v8::Value&gt; &amp;args);&#10;    static void loadFromQrc(const v8::FunctionCallbackInfo&lt;v8::Value&gt; &amp;args);&#10;&#10;    // Node.js environment&#10;    std::unique_ptr&lt;node::CommonEnvironmentSetup&gt; m_setup;&#10;    std::unique_ptr&lt;node::MultiIsolatePlatform&gt; m_platform;&#10;    std::unique_ptr&lt;node::InitializationResult&gt; m_initResult;&#10;    v8::Isolate *m_isolate;&#10;    node::Environment *m_env;&#10;    v8::Global&lt;v8::Function&gt; m_handleMessageFunction;&#10;    &#10;    // Thread synchronization&#10;    QMutex m_messageMutex;&#10;    QWaitCondition m_messageCondition;&#10;    QQueue&lt;NodeMessage&gt; m_messageQueue;&#10;    std::atomic&lt;bool&gt; m_running;&#10;    &#10;    // Callback storage for concurrent messages&#10;    QMap&lt;QString, std::function&lt;void(const QJsonObject&amp;)&gt;&gt; m_callbacks;&#10;    QMutex m_callbackMutex;&#10;    &#10;    static const char* JS_ENTRY_PATH;&#10;    static const char* JS_ENTRY_QRC_PATH;&#10;    static NodeThread* s_instance;&#10;};&#10;&#10;#endif // NODE_THREAD_H" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>